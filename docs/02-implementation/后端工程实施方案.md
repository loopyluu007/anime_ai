# åç«¯å·¥ç¨‹å®æ–½æ–¹æ¡ˆ

> **ç›®æ ‡**: æ„å»º AIæ¼«å¯¼ åç«¯æœåŠ¡ç³»ç»Ÿ  
> **æŠ€æœ¯æ ˆ**: Python FastAPI + PostgreSQL + Redis  
> **ç‰ˆæœ¬**: v1.0

---

## ğŸ“‹ ç›®å½•

1. [é¡¹ç›®åˆå§‹åŒ–](#é¡¹ç›®åˆå§‹åŒ–)
2. [ç›®å½•ç»“æ„](#ç›®å½•ç»“æ„)
3. [æ ¸å¿ƒæ¨¡å—å®ç°](#æ ¸å¿ƒæ¨¡å—å®ç°)
4. [æ•°æ®åº“é…ç½®](#æ•°æ®åº“é…ç½®)
5. [API å®ç°](#api-å®ç°)
6. [ç¬¬ä¸‰æ–¹ API é›†æˆ](#ç¬¬ä¸‰æ–¹-api-é›†æˆ)
7. [WebSocket å®ç°](#websocket-å®ç°)
8. [éƒ¨ç½²é…ç½®](#éƒ¨ç½²é…ç½®)
9. [æµ‹è¯•æ–¹æ¡ˆ](#æµ‹è¯•æ–¹æ¡ˆ)

---

## ğŸš€ é¡¹ç›®åˆå§‹åŒ–

### 1. åˆ›å»ºé¡¹ç›®ç›®å½•

```bash
mkdir -p backend
cd backend
```

### 2. é¡¹ç›®ç»“æ„

```
backend/
â”œâ”€â”€ api-gateway/          # API ç½‘å…³æœåŠ¡
â”œâ”€â”€ services/             # ä¸šåŠ¡æœåŠ¡
â”‚   â”œâ”€â”€ agent-service/    # Agent ä¸šåŠ¡æœåŠ¡
â”‚   â”œâ”€â”€ media-service/    # åª’ä½“æœåŠ¡
â”‚   â””â”€â”€ data-service/     # æ•°æ®æœåŠ¡
â”œâ”€â”€ shared/               # å…±äº«æ¨¡å—
â”œâ”€â”€ infrastructure/       # åŸºç¡€è®¾æ–½
â”œâ”€â”€ tests/                # æµ‹è¯•
â””â”€â”€ scripts/              # è„šæœ¬
```

### 3. ç¯å¢ƒè¦æ±‚

- Python 3.11+
- PostgreSQL 15+
- Redis 7+
- Docker & Docker Compose (å¯é€‰)

### 4. åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ

```bash
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
```

---

## ğŸ“ ç›®å½•ç»“æ„

### å®Œæ•´ç›®å½•ç»“æ„

```
backend/
â”œâ”€â”€ api-gateway/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.py          # JWT è®¤è¯ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ rate_limit.py    # é™æµä¸­é—´ä»¶
â”‚   â”‚   â”‚   â””â”€â”€ cors.py          # CORS ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ gateway.py       # ç½‘å…³è·¯ç”±
â”‚   â”‚   â””â”€â”€ config/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â””â”€â”€ settings.py      # é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â””â”€â”€ Dockerfile
â”‚
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ agent-service/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ conversations.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tasks.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ screenplays.py
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ conversation_service.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ task_service.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ screenplay_service.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ agent_service.py
â”‚   â”‚   â”‚   â”œâ”€â”€ clients/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ glm_client.py
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ conversation.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ task.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ screenplay.py
â”‚   â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚       â””â”€â”€ logger.py
â”‚   â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”‚   â””â”€â”€ Dockerfile
â”‚   â”‚
â”‚   â”œâ”€â”€ media-service/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ images.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ videos.py
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ image_service.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ video_service.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ storage_service.py
â”‚   â”‚   â”‚   â”œâ”€â”€ clients/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tuzi_client.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ gemini_client.py
â”‚   â”‚   â”‚   â”œâ”€â”€ processors/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ffmpeg_processor.py
â”‚   â”‚   â”‚   â””â”€â”€ models/
â”‚   â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚       â””â”€â”€ media_file.py
â”‚   â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”‚   â””â”€â”€ Dockerfile
â”‚   â”‚
â”‚   â””â”€â”€ data-service/
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ main.py
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ api/
â”‚       â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”‚   â”œâ”€â”€ users.py
â”‚       â”‚   â”‚   â””â”€â”€ analytics.py
â”‚       â”‚   â”œâ”€â”€ services/
â”‚       â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”‚   â”œâ”€â”€ user_service.py
â”‚       â”‚   â”‚   â””â”€â”€ auth_service.py
â”‚       â”‚   â”œâ”€â”€ repositories/
â”‚       â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”‚   â”œâ”€â”€ user_repository.py
â”‚       â”‚   â”‚   â”œâ”€â”€ conversation_repository.py
â”‚       â”‚   â”‚   â””â”€â”€ task_repository.py
â”‚       â”‚   â””â”€â”€ models/
â”‚       â”‚       â”œâ”€â”€ __init__.py
â”‚       â”‚       â””â”€â”€ user.py
â”‚       â”œâ”€â”€ requirements.txt
â”‚       â””â”€â”€ Dockerfile
â”‚
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py
â”‚   â”‚   â”œâ”€â”€ conversation.py
â”‚   â”‚   â”œâ”€â”€ message.py
â”‚   â”‚   â”œâ”€â”€ task.py
â”‚   â”‚   â””â”€â”€ screenplay.py
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ logger.py
â”‚   â”‚   â”œâ”€â”€ exceptions.py
â”‚   â”‚   â””â”€â”€ validators.py
â”‚   â””â”€â”€ config/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ database.py
â”‚       â””â”€â”€ redis.py
â”‚
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â”‚   â””â”€â”€ 001_initial.sql  # åˆå§‹è¿ç§»ï¼ˆåŒ…å«æ‰€æœ‰è¡¨ç»“æ„å’Œç´¢å¼•ï¼‰
â”‚   â”‚   â””â”€â”€ seeds/
â”‚   â”‚       â””â”€â”€ initial_data.sql
â”‚   â”œâ”€â”€ docker/
â”‚   â”‚   â”œâ”€â”€ docker-compose.yml
â”‚   â”‚   â”œâ”€â”€ Dockerfile.gateway
â”‚   â”‚   â”œâ”€â”€ Dockerfile.agent
â”‚   â”‚   â”œâ”€â”€ Dockerfile.media
â”‚   â”‚   â””â”€â”€ Dockerfile.data
â”‚   â””â”€â”€ nginx/
â”‚       â””â”€â”€ nginx.conf
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ migrate.py
â”‚   â”œâ”€â”€ seed.py
â”‚   â””â”€â”€ deploy.sh
â”‚
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â””â”€â”€ README.md
```

---

## ğŸ”§ æ ¸å¿ƒæ¨¡å—å®ç°

### 1. å…±äº«æ¨¡å— - æ•°æ®æ¨¡å‹

#### `shared/models/user.py`

```python
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional
from uuid import UUID

class UserBase(BaseModel):
    username: str
    email: EmailStr

class UserCreate(UserBase):
    password: str

class UserResponse(UserBase):
    id: UUID
    avatar: Optional[str] = None
    is_active: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True
```

#### `shared/models/conversation.py`

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional
from uuid import UUID

class ConversationBase(BaseModel):
    title: str

class ConversationCreate(ConversationBase):
    pass

class ConversationResponse(ConversationBase):
    id: UUID
    user_id: UUID
    preview_text: Optional[str] = None
    message_count: int = 0
    is_pinned: bool = False
    last_accessed_at: datetime
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class ConversationUpdate(BaseModel):
    title: Optional[str] = None
    is_pinned: Optional[bool] = None
```

#### `shared/models/message.py`

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Dict, Any
from uuid import UUID
from enum import Enum

class MessageRole(str, Enum):
    USER = "user"
    ASSISTANT = "assistant"

class MessageType(str, Enum):
    TEXT = "text"
    IMAGE = "image"
    VIDEO = "video"
    SCREENPLAY = "screenplay"

class MessageBase(BaseModel):
    role: MessageRole
    content: str
    type: MessageType = MessageType.TEXT
    metadata: Optional[Dict[str, Any]] = None

class MessageCreate(MessageBase):
    conversation_id: UUID

class MessageResponse(MessageBase):
    id: UUID
    conversation_id: UUID
    created_at: datetime

    class Config:
        from_attributes = True
```

#### `shared/models/task.py`

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Dict, Any
from uuid import UUID
from enum import Enum

class TaskType(str, Enum):
    SCREENPLAY = "screenplay"
    IMAGE = "image"
    VIDEO = "video"

class TaskStatus(str, Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class TaskBase(BaseModel):
    type: TaskType
    conversation_id: Optional[UUID] = None
    params: Dict[str, Any]

class TaskCreate(TaskBase):
    pass

class TaskResponse(TaskBase):
    id: UUID
    user_id: UUID
    status: TaskStatus
    progress: int = 0
    result: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None
    created_at: datetime
    updated_at: datetime
    completed_at: Optional[datetime] = None

    class Config:
        from_attributes = True
```

#### `shared/models/screenplay.py`

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional, List
from uuid import UUID
from enum import Enum

class SceneStatus(str, Enum):
    PENDING = "pending"
    GENERATING = "generating"
    COMPLETED = "completed"
    FAILED = "failed"

class SceneBase(BaseModel):
    scene_id: int
    narration: str
    image_prompt: str
    video_prompt: str
    character_description: Optional[str] = None

class SceneResponse(SceneBase):
    id: UUID
    screenplay_id: UUID
    image_url: Optional[str] = None
    video_url: Optional[str] = None
    status: SceneStatus
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class CharacterSheetBase(BaseModel):
    name: str
    description: Optional[str] = None

class CharacterSheetResponse(CharacterSheetBase):
    id: UUID
    screenplay_id: UUID
    combined_view_url: Optional[str] = None
    front_view_url: Optional[str] = None
    side_view_url: Optional[str] = None
    back_view_url: Optional[str] = None
    created_at: datetime

    class Config:
        from_attributes = True

class ScreenplayStatus(str, Enum):
    DRAFT = "draft"
    CONFIRMED = "confirmed"
    GENERATING = "generating"
    COMPLETED = "completed"
    FAILED = "failed"

class ScreenplayBase(BaseModel):
    title: str

class ScreenplayResponse(ScreenplayBase):
    id: UUID
    task_id: UUID
    user_id: UUID
    status: ScreenplayStatus
    scenes: List[SceneResponse] = []
    character_sheets: List[CharacterSheetResponse] = []
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True
```

### 2. å…±äº«æ¨¡å— - å·¥å…·ç±»

#### `shared/utils/logger.py`

```python
import logging
import sys
from datetime import datetime

def setup_logger(name: str, level: int = logging.INFO) -> logging.Logger:
    """è®¾ç½®æ—¥å¿—è®°å½•å™¨"""
    logger = logging.getLogger(name)
    logger.setLevel(level)
    
    if not logger.handlers:
        handler = logging.StreamHandler(sys.stdout)
        handler.setLevel(level)
        
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    
    return logger
```

#### `shared/utils/exceptions.py`

```python
from fastapi import HTTPException, status

class DirectorAIException(HTTPException):
    """åŸºç¡€å¼‚å¸¸ç±»"""
    def __init__(self, status_code: int, detail: str, error_code: int = None):
        super().__init__(status_code=status_code, detail=detail)
        self.error_code = error_code

class ValidationError(DirectorAIException):
    """å‚æ•°éªŒè¯é”™è¯¯"""
    def __init__(self, detail: str, field: str = None):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=detail,
            error_code=1000
        )
        self.field = field

class AuthenticationError(DirectorAIException):
    """è®¤è¯é”™è¯¯"""
    def __init__(self, detail: str = "è®¤è¯å¤±è´¥"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail,
            error_code=2000
        )

class NotFoundError(DirectorAIException):
    """èµ„æºä¸å­˜åœ¨"""
    def __init__(self, resource: str = "èµ„æº"):
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"{resource}ä¸å­˜åœ¨",
            error_code=3000
        )
```

### 3. å…±äº«æ¨¡å— - æ•°æ®åº“é…ç½®

#### `shared/config/database.py`

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://user:password@localhost:5432/directorai"
)

engine = create_engine(DATABASE_URL, pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    """è·å–æ•°æ®åº“ä¼šè¯"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

---

## ğŸ—„ï¸ æ•°æ®åº“é…ç½®

### 1. æ•°æ®åº“æ¨¡å‹ (SQLAlchemy)

#### `shared/models/db_models.py`

```python
from sqlalchemy import Column, String, Integer, Boolean, DateTime, ForeignKey, Text, JSON, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid
from shared.config.database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(255), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    avatar_url = Column(Text)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    conversations = relationship("Conversation", back_populates="user", cascade="all, delete-orphan")
    tasks = relationship("Task", back_populates="user", cascade="all, delete-orphan")

class Conversation(Base):
    __tablename__ = "conversations"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    title = Column(String(255), nullable=False)
    preview_text = Column(Text)
    message_count = Column(Integer, default=0)
    is_pinned = Column(Boolean, default=False)
    last_accessed_at = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    user = relationship("User", back_populates="conversations")
    messages = relationship("Message", back_populates="conversation", cascade="all, delete-orphan")
    tasks = relationship("Task", back_populates="conversation")

class Message(Base):
    __tablename__ = "messages"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    conversation_id = Column(UUID(as_uuid=True), ForeignKey("conversations.id", ondelete="CASCADE"), nullable=False)
    role = Column(String(20), nullable=False)
    content = Column(Text, nullable=False)
    type = Column(String(20), default="text")
    metadata = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    conversation = relationship("Conversation", back_populates="messages")

class Task(Base):
    __tablename__ = "tasks"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    conversation_id = Column(UUID(as_uuid=True), ForeignKey("conversations.id", ondelete="SET NULL"))
    type = Column(String(50), nullable=False)
    status = Column(String(20), default="pending")
    progress = Column(Integer, default=0)
    params = Column(JSON)
    result = Column(JSON)
    error_message = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    completed_at = Column(DateTime)
    
    user = relationship("User", back_populates="tasks")
    conversation = relationship("Conversation", back_populates="tasks")
    screenplay = relationship("Screenplay", back_populates="task", uselist=False)

class Screenplay(Base):
    __tablename__ = "screenplays"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    task_id = Column(UUID(as_uuid=True), ForeignKey("tasks.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    title = Column(String(255), nullable=False)
    status = Column(String(20), default="draft")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    task = relationship("Task", back_populates="screenplay")
    scenes = relationship("Scene", back_populates="screenplay", cascade="all, delete-orphan")
    character_sheets = relationship("CharacterSheet", back_populates="screenplay", cascade="all, delete-orphan")

class Scene(Base):
    __tablename__ = "scenes"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    screenplay_id = Column(UUID(as_uuid=True), ForeignKey("screenplays.id", ondelete="CASCADE"), nullable=False)
    scene_id = Column(Integer, nullable=False)
    narration = Column(Text, nullable=False)
    image_prompt = Column(Text, nullable=False)
    video_prompt = Column(Text, nullable=False)
    character_description = Column(Text)
    image_url = Column(Text)
    video_url = Column(Text)
    status = Column(String(20), default="pending")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    screenplay = relationship("Screenplay", back_populates="scenes")
    
    __table_args__ = (
        {"postgresql_unique_constraint": ("screenplay_id", "scene_id")},
    )

class CharacterSheet(Base):
    __tablename__ = "character_sheets"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    screenplay_id = Column(UUID(as_uuid=True), ForeignKey("screenplays.id", ondelete="CASCADE"), nullable=False)
    name = Column(String(100), nullable=False)
    description = Column(Text)
    combined_view_url = Column(Text)
    front_view_url = Column(Text)
    side_view_url = Column(Text)
    back_view_url = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    screenplay = relationship("Screenplay", back_populates="character_sheets")
```

### 2. æ•°æ®åº“è¿ç§»è„šæœ¬

æœ¬é¡¹ç›®ä¸ºæ–°éƒ¨ç½²ï¼Œä½¿ç”¨å•ä¸€çš„åˆå§‹è¿ç§»æ–‡ä»¶ã€‚`001_initial.sql` åŒ…å«æ‰€æœ‰è¡¨ç»“æ„ã€ç´¢å¼•å’Œçº¦æŸï¼Œé€‚ç”¨äºæ–°éƒ¨ç½²åœºæ™¯ã€‚

#### `infrastructure/database/migrations/001_initial.sql`

```sql
-- åˆ›å»ºç”¨æˆ·è¡¨
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    avatar_url TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºå¯¹è¯è¡¨
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    preview_text TEXT,
    message_count INTEGER DEFAULT 0,
    is_pinned BOOLEAN DEFAULT false,
    last_accessed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºæ¶ˆæ¯è¡¨
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant')),
    content TEXT NOT NULL,
    type VARCHAR(20) NOT NULL DEFAULT 'text' CHECK (type IN ('text', 'image', 'video', 'screenplay')),
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºä»»åŠ¡è¡¨
CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    conversation_id UUID REFERENCES conversations(id) ON DELETE SET NULL,
    type VARCHAR(50) NOT NULL CHECK (type IN ('screenplay', 'image', 'video')),
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'cancelled')),
    progress INTEGER DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
    params JSONB,
    result JSONB,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- åˆ›å»ºå‰§æœ¬è¡¨
CREATE TABLE screenplays (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'confirmed', 'generating', 'completed', 'failed')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºåœºæ™¯è¡¨
CREATE TABLE scenes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    screenplay_id UUID NOT NULL REFERENCES screenplays(id) ON DELETE CASCADE,
    scene_id INTEGER NOT NULL,
    narration TEXT NOT NULL,
    image_prompt TEXT NOT NULL,
    video_prompt TEXT NOT NULL,
    character_description TEXT,
    image_url TEXT,
    video_url TEXT,
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'generating', 'completed', 'failed')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(screenplay_id, scene_id)
);

-- åˆ›å»ºè§’è‰²è®¾å®šè¡¨
CREATE TABLE character_sheets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    screenplay_id UUID NOT NULL REFERENCES screenplays(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    combined_view_url TEXT,
    front_view_url TEXT,
    side_view_url TEXT,
    back_view_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºåª’ä½“æ–‡ä»¶è¡¨
CREATE TABLE media_files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    type VARCHAR(20) NOT NULL CHECK (type IN ('image', 'video')),
    original_filename VARCHAR(255),
    storage_path TEXT NOT NULL,
    url TEXT NOT NULL,
    mime_type VARCHAR(100),
    size BIGINT,
    width INTEGER,
    height INTEGER,
    duration INTEGER,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_conversations_user_id ON conversations(user_id);
CREATE INDEX idx_conversations_user_updated ON conversations(user_id, updated_at DESC);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_screenplays_task_id ON screenplays(task_id);
CREATE INDEX idx_scenes_screenplay_id ON scenes(screenplay_id);
```

---

## ğŸ”Œ API å®ç°

### 1. Agent Service - è®¤è¯ API

#### `services/agent-service/src/api/auth.py`

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from typing import Optional

from shared.config.database import get_db
from shared.models.user import UserCreate, UserResponse
from shared.utils.exceptions import AuthenticationError
from services.agent-service.src.services.auth_service import AuthService

router = APIRouter(prefix="/auth", tags=["è®¤è¯"])

SECRET_KEY = "your-secret-key"  # ä»ç¯å¢ƒå˜é‡è¯»å–
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """éªŒè¯å¯†ç """
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """ç”Ÿæˆå¯†ç å“ˆå¸Œ"""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    """åˆ›å»ºè®¿é—®ä»¤ç‰Œ"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
):
    """è·å–å½“å‰ç”¨æˆ·"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise AuthenticationError("Token æ— æ•ˆ")
    except JWTError:
        raise AuthenticationError("Token æ— æ•ˆ")
    
    auth_service = AuthService(db)
    user = auth_service.get_user_by_id(user_id)
    if user is None:
        raise AuthenticationError("ç”¨æˆ·ä¸å­˜åœ¨")
    return user

@router.post("/register", response_model=dict)
async def register(user_data: UserCreate, db: Session = Depends(get_db)):
    """ç”¨æˆ·æ³¨å†Œ"""
    auth_service = AuthService(db)
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
    if auth_service.get_user_by_email(user_data.email):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="é‚®ç®±å·²è¢«æ³¨å†Œ"
        )
    
    # åˆ›å»ºç”¨æˆ·
    user = auth_service.create_user(user_data)
    
    # ç”Ÿæˆ Token
    access_token = create_access_token(data={"sub": str(user.id)})
    
    return {
        "code": 200,
        "message": "æ³¨å†ŒæˆåŠŸ",
        "data": {
            "userId": str(user.id),
            "token": access_token,
            "refreshToken": access_token  # ç®€åŒ–å®ç°ï¼Œå®é™…åº”å•ç‹¬ç”Ÿæˆ
        }
    }

@router.post("/login", response_model=dict)
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """ç”¨æˆ·ç™»å½•"""
    auth_service = AuthService(db)
    user = auth_service.get_user_by_email(form_data.username)  # OAuth2 ä½¿ç”¨ username å­—æ®µä¼ é‚®ç®±
    
    if not user or not verify_password(form_data.password, user.password_hash):
        raise AuthenticationError("é‚®ç®±æˆ–å¯†ç é”™è¯¯")
    
    access_token = create_access_token(data={"sub": str(user.id)})
    
    return {
        "code": 200,
        "message": "ç™»å½•æˆåŠŸ",
        "data": {
            "userId": str(user.id),
            "token": access_token,
            "refreshToken": access_token,
            "expiresIn": ACCESS_TOKEN_EXPIRE_MINUTES * 60
        }
    }

@router.get("/me", response_model=dict)
async def get_me(current_user = Depends(get_current_user)):
    """è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯"""
    return {
        "code": 200,
        "data": {
            "id": str(current_user.id),
            "username": current_user.username,
            "email": current_user.email,
            "avatar": current_user.avatar_url,
            "createdAt": current_user.created_at.isoformat()
        }
    }
```

### 2. Agent Service - å¯¹è¯ API

#### `services/agent-service/src/api/conversations.py`

```python
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from uuid import UUID

from shared.config.database import get_db
from shared.models.conversation import ConversationCreate, ConversationResponse, ConversationUpdate
from services.agent-service.src.services.conversation_service import ConversationService
from services.agent-service.src.api.auth import get_current_user

router = APIRouter(prefix="/conversations", tags=["å¯¹è¯"])

@router.post("", response_model=dict)
async def create_conversation(
    conversation_data: ConversationCreate,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """åˆ›å»ºå¯¹è¯"""
    service = ConversationService(db)
    conversation = service.create_conversation(current_user.id, conversation_data)
    
    return {
        "code": 200,
        "message": "åˆ›å»ºæˆåŠŸ",
        "data": {
            "id": str(conversation.id),
            "title": conversation.title,
            "messageCount": conversation.message_count,
            "isPinned": conversation.is_pinned,
            "createdAt": conversation.created_at.isoformat()
        }
    }

@router.get("", response_model=dict)
async def get_conversations(
    page: int = Query(1, ge=1),
    pageSize: int = Query(20, ge=1, le=100),
    pinned: Optional[bool] = None,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """è·å–å¯¹è¯åˆ—è¡¨"""
    service = ConversationService(db)
    conversations, total = service.get_conversations(
        user_id=current_user.id,
        page=page,
        page_size=pageSize,
        pinned=pinned
    )
    
    return {
        "code": 200,
        "data": {
            "page": page,
            "pageSize": pageSize,
            "total": total,
            "items": [
                {
                    "id": str(c.id),
                    "title": c.title,
                    "previewText": c.preview_text,
                    "messageCount": c.message_count,
                    "isPinned": c.is_pinned,
                    "lastAccessedAt": c.last_accessed_at.isoformat(),
                    "createdAt": c.created_at.isoformat()
                }
                for c in conversations
            ]
        }
    }

@router.get("/{conversation_id}", response_model=dict)
async def get_conversation(
    conversation_id: UUID,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """è·å–å¯¹è¯è¯¦æƒ…"""
    service = ConversationService(db)
    conversation = service.get_conversation(conversation_id, current_user.id)
    
    if not conversation:
        raise HTTPException(status_code=404, detail="å¯¹è¯ä¸å­˜åœ¨")
    
    return {
        "code": 200,
        "data": {
            "id": str(conversation.id),
            "title": conversation.title,
            "messageCount": conversation.message_count,
            "isPinned": conversation.is_pinned,
            "createdAt": conversation.created_at.isoformat(),
            "updatedAt": conversation.updated_at.isoformat()
        }
    }

@router.put("/{conversation_id}", response_model=dict)
async def update_conversation(
    conversation_id: UUID,
    conversation_data: ConversationUpdate,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """æ›´æ–°å¯¹è¯"""
    service = ConversationService(db)
    conversation = service.update_conversation(
        conversation_id, current_user.id, conversation_data
    )
    
    if not conversation:
        raise HTTPException(status_code=404, detail="å¯¹è¯ä¸å­˜åœ¨")
    
    return {
        "code": 200,
        "message": "æ›´æ–°æˆåŠŸ",
        "data": {
            "id": str(conversation.id),
            "title": conversation.title,
            "isPinned": conversation.is_pinned
        }
    }

@router.delete("/{conversation_id}", response_model=dict)
async def delete_conversation(
    conversation_id: UUID,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """åˆ é™¤å¯¹è¯"""
    service = ConversationService(db)
    success = service.delete_conversation(conversation_id, current_user.id)
    
    if not success:
        raise HTTPException(status_code=404, detail="å¯¹è¯ä¸å­˜åœ¨")
    
    return {
        "code": 200,
        "message": "åˆ é™¤æˆåŠŸ"
    }
```

### 3. Agent Service - ä»»åŠ¡ API

#### `services/agent-service/src/api/tasks.py`

```python
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List
from uuid import UUID

from shared.config.database import get_db
from shared.models.task import TaskCreate, TaskResponse
from services.agent-service.src.services.task_service import TaskService
from services.agent-service.src.api.auth import get_current_user

router = APIRouter(prefix="/tasks", tags=["ä»»åŠ¡"])

@router.post("", response_model=dict)
async def create_task(
    task_data: TaskCreate,
    background_tasks: BackgroundTasks,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """åˆ›å»ºä»»åŠ¡"""
    service = TaskService(db)
    task = service.create_task(current_user.id, task_data)
    
    # å¦‚æœæ˜¯å‰§æœ¬ç”Ÿæˆä»»åŠ¡ï¼Œå¯åŠ¨åå°å¤„ç†
    if task_data.type == "screenplay":
        background_tasks.add_task(
            service.process_screenplay_task,
            task.id
        )
    
    return {
        "code": 200,
        "message": "ä»»åŠ¡åˆ›å»ºæˆåŠŸ",
        "data": {
            "id": str(task.id),
            "type": task.type,
            "status": task.status,
            "progress": task.progress,
            "createdAt": task.created_at.isoformat()
        }
    }

@router.get("", response_model=dict)
async def get_tasks(
    page: int = 1,
    pageSize: int = 20,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """è·å–ä»»åŠ¡åˆ—è¡¨"""
    service = TaskService(db)
    tasks, total = service.get_tasks(
        user_id=current_user.id,
        page=page,
        page_size=pageSize
    )
    
    return {
        "code": 200,
        "data": {
            "page": page,
            "pageSize": pageSize,
            "total": total,
            "items": [
                {
                    "id": str(t.id),
                    "type": t.type,
                    "status": t.status,
                    "progress": t.progress,
                    "createdAt": t.created_at.isoformat()
                }
                for t in tasks
            ]
        }
    }

@router.get("/{task_id}", response_model=dict)
async def get_task(
    task_id: UUID,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """è·å–ä»»åŠ¡è¯¦æƒ…"""
    service = TaskService(db)
    task = service.get_task(task_id, current_user.id)
    
    if not task:
        raise HTTPException(status_code=404, detail="ä»»åŠ¡ä¸å­˜åœ¨")
    
    return {
        "code": 200,
        "data": {
            "id": str(task.id),
            "type": task.type,
            "status": task.status,
            "progress": task.progress,
            "result": task.result,
            "errorMessage": task.error_message,
            "createdAt": task.created_at.isoformat(),
            "updatedAt": task.updated_at.isoformat()
        }
    }

@router.get("/{task_id}/progress", response_model=dict)
async def get_task_progress(
    task_id: UUID,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """è·å–ä»»åŠ¡è¿›åº¦"""
    service = TaskService(db)
    progress = service.get_task_progress(task_id, current_user.id)
    
    if not progress:
        raise HTTPException(status_code=404, detail="ä»»åŠ¡ä¸å­˜åœ¨")
    
    return {
        "code": 200,
        "data": progress
    }
```

---

## ğŸ”— ç¬¬ä¸‰æ–¹ API é›†æˆ

### 1. GLM å®¢æˆ·ç«¯

#### `services/agent-service/src/clients/glm_client.py`

```python
import httpx
import os
from typing import Dict, Any, Optional, AsyncGenerator
import json

class GLMClient:
    """æ™ºè°± GLM API å®¢æˆ·ç«¯"""
    
    def __init__(self):
        self.base_url = "https://open.bigmodel.cn/api/paas/v4"
        self.api_key = os.getenv("GLM_API_KEY")
        self.client = httpx.AsyncClient(
            base_url=self.base_url,
            timeout=60.0,
            headers={
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
        )
    
    async def chat_completion(
        self,
        messages: list,
        model: str = "glm-4",
        temperature: float = 0.7,
        stream: bool = False
    ) -> Dict[str, Any]:
        """èŠå¤©è¡¥å…¨"""
        response = await self.client.post(
            "/chat/completions",
            json={
                "model": model,
                "messages": messages,
                "temperature": temperature,
                "stream": stream
            }
        )
        response.raise_for_status()
        return response.json()
    
    async def generate_screenplay(
        self,
        user_prompt: str,
        user_images: Optional[list] = None,
        scene_count: int = 7,
        character_count: int = 2
    ) -> Dict[str, Any]:
        """ç”Ÿæˆå‰§æœ¬"""
        system_prompt = self._build_screenplay_system_prompt(scene_count, character_count)
        
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]
        
        # å¦‚æœæœ‰ç”¨æˆ·ä¸Šä¼ çš„å›¾ç‰‡ï¼Œæ·»åŠ åˆ°æ¶ˆæ¯ä¸­
        if user_images:
            content = [{"type": "text", "text": user_prompt}]
            for img in user_images:
                content.append({
                    "type": "image_url",
                    "image_url": {"url": f"data:image/jpeg;base64,{img}"}
                })
            messages[1]["content"] = content
        
        response = await self.chat_completion(messages, model="glm-4")
        
        # è§£æ JSON å“åº”
        content = response["choices"][0]["message"]["content"]
        screenplay_data = json.loads(content)
        
        return screenplay_data
    
    def _build_screenplay_system_prompt(self, scene_count: int, character_count: int) -> str:
        """æ„å»ºå‰§æœ¬ç”Ÿæˆç³»ç»Ÿæç¤ºè¯"""
        return f"""You are DirectorAI, a SCREENPLAY CREATION AGENT for short video production.

YOUR MISSION: Convert user's creative idea into a multi-scene screenplay with exactly {scene_count} scenes.
Each scene will be turned into: Narration (Chinese) â†’ Image â†’ Video.

CRITICAL OUTPUT FORMAT:
You MUST respond with ONLY a valid JSON object. No markdown, no explanations, no thinking process.

JSON SCHEMA:
{{
  "task_id": "unique_task_id",
  "script_title": "å‰§æœ¬æ ‡é¢˜",
  "scenes": [
    {{
      "scene_id": 1,
      "narration": "ä¸­æ–‡æ—ç™½ï¼Œæè¿°è¿™ä¸€å¹•çš„å†…å®¹",
      "image_prompt": "Detailed English visual description for image generation",
      "video_prompt": "English motion/description for video animation",
      "character_description": "Detailed character description for consistency across scenes",
      "image_url": null,
      "video_url": null,
      "status": "pending"
    }}
  ],
  "characters": [
    {{
      "name": "è§’è‰²åç§°",
      "description": "è§’è‰²æè¿°"
    }}
  ]
}}

GUIDELINES:
1. NUMBER OF SCENES: EXACTLY {scene_count} SCENES
2. CHARACTER CONSISTENCY: First scene's image_prompt MUST contain detailed character appearance
3. NARRATION: Short, evocative descriptions in Chinese (1-2 sentences per scene)
4. IMAGE_PROMPT: Always start with "anime style, manga art, 2D animation, cel shaded"
5. VIDEO_PROMPT: Motion description in English
"""
    
    async def close(self):
        """å…³é—­å®¢æˆ·ç«¯"""
        await self.client.aclose()
```

### 2. Tuzi å®¢æˆ·ç«¯ï¼ˆè§†é¢‘ç”Ÿæˆï¼‰

#### `services/media-service/src/clients/tuzi_client.py`

```python
import httpx
import os
from typing import Dict, Any, Optional
import asyncio

class TuziClient:
    """Tuzi API å®¢æˆ·ç«¯ï¼ˆè§†é¢‘ç”Ÿæˆï¼‰"""
    
    def __init__(self):
        self.base_url = "https://api.ourzhishi.top"
        self.api_key = os.getenv("TUZI_API_KEY")
        self.client = httpx.AsyncClient(
            base_url=self.base_url,
            timeout=300.0,
            headers={
                "Authorization": f"Bearer {self.api_key}"
            }
        )
    
    async def generate_video(
        self,
        prompt: str,
        image_url: Optional[str] = None,
        seconds: str = "10",
        model: str = "sora-1",
        reference_images: Optional[list] = None
    ) -> Dict[str, Any]:
        """ç”Ÿæˆè§†é¢‘"""
        data = {
            "model": model,
            "prompt": prompt,
            "seconds": seconds
        }
        
        files = {}
        if image_url:
            data["input_reference"] = image_url
        
        if reference_images:
            for i, img_url in enumerate(reference_images):
                data[f"input_reference_{i}"] = img_url
        
        response = await self.client.post(
            "/v1/videos",
            data=data,
            files=files
        )
        response.raise_for_status()
        return response.json()
    
    async def get_video_status(self, task_id: str) -> Dict[str, Any]:
        """è·å–è§†é¢‘ç”ŸæˆçŠ¶æ€"""
        response = await self.client.get(f"/v1/videos/{task_id}")
        response.raise_for_status()
        return response.json()
    
    async def wait_for_video(
        self,
        task_id: str,
        max_wait_time: int = 300,
        poll_interval: int = 5
    ) -> Dict[str, Any]:
        """ç­‰å¾…è§†é¢‘ç”Ÿæˆå®Œæˆ"""
        start_time = asyncio.get_event_loop().time()
        
        while True:
            status = await self.get_video_status(task_id)
            
            if status.get("status") == "completed":
                return status
            
            if status.get("status") == "failed":
                raise Exception(f"è§†é¢‘ç”Ÿæˆå¤±è´¥: {status.get('error')}")
            
            elapsed = asyncio.get_event_loop().time() - start_time
            if elapsed > max_wait_time:
                raise TimeoutError("è§†é¢‘ç”Ÿæˆè¶…æ—¶")
            
            await asyncio.sleep(poll_interval)
    
    async def close(self):
        """å…³é—­å®¢æˆ·ç«¯"""
        await self.client.aclose()
```

### 3. Gemini å®¢æˆ·ç«¯ï¼ˆå›¾ç‰‡ç”Ÿæˆï¼‰

#### `services/media-service/src/clients/gemini_client.py`

```python
import httpx
import os
from typing import Dict, Any, Optional, List

class GeminiClient:
    """Gemini API å®¢æˆ·ç«¯ï¼ˆå›¾ç‰‡ç”Ÿæˆï¼‰"""
    
    def __init__(self):
        self.base_url = "https://api.ourzhishi.top"
        self.api_key = os.getenv("GEMINI_API_KEY")
        self.client = httpx.AsyncClient(
            base_url=self.base_url,
            timeout=120.0,
            headers={
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
        )
    
    async def generate_image(
        self,
        prompt: str,
        model: str = "gemini-3-pro-image-preview-hd",
        size: str = "1024x1024",
        reference_images: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """ç”Ÿæˆå›¾ç‰‡"""
        payload = {
            "model": model,
            "prompt": prompt,
            "size": size,
            "response_format": "url",
            "n": 1
        }
        
        if reference_images:
            payload["image"] = reference_images
        
        response = await self.client.post(
            "/v1/images/generations",
            json=payload
        )
        response.raise_for_status()
        return response.json()
```

---

## ğŸ”Œ WebSocket å®ç°

### `services/agent-service/src/api/websocket.py`

```python
from fastapi import WebSocket, WebSocketDisconnect, Depends
from typing import Dict, Set
import json
import asyncio
from uuid import UUID

class ConnectionManager:
    """WebSocket è¿æ¥ç®¡ç†å™¨"""
    
    def __init__(self):
        self.active_connections: Dict[UUID, Set[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, user_id: UUID):
        """è¿æ¥ WebSocket"""
        await websocket.accept()
        if user_id not in self.active_connections:
            self.active_connections[user_id] = set()
        self.active_connections[user_id].add(websocket)
    
    def disconnect(self, websocket: WebSocket, user_id: UUID):
        """æ–­å¼€ WebSocket"""
        if user_id in self.active_connections:
            self.active_connections[user_id].discard(websocket)
            if not self.active_connections[user_id]:
                del self.active_connections[user_id]
    
    async def send_personal_message(self, message: dict, user_id: UUID):
        """å‘é€ä¸ªäººæ¶ˆæ¯"""
        if user_id in self.active_connections:
            disconnected = set()
            for connection in self.active_connections[user_id]:
                try:
                    await connection.send_json(message)
                except:
                    disconnected.add(connection)
            
            # æ¸…ç†æ–­å¼€çš„è¿æ¥
            for conn in disconnected:
                self.active_connections[user_id].discard(conn)
    
    async def broadcast(self, message: dict):
        """å¹¿æ’­æ¶ˆæ¯"""
        for user_id, connections in self.active_connections.items():
            for connection in connections:
                try:
                    await connection.send_json(message)
                except:
                    pass

manager = ConnectionManager()

async def websocket_endpoint(websocket: WebSocket, user_id: UUID):
    """WebSocket ç«¯ç‚¹"""
    await manager.connect(websocket, user_id)
    try:
        while True:
            data = await websocket.receive_text()
            # å¤„ç†å®¢æˆ·ç«¯æ¶ˆæ¯ï¼ˆå¦‚è®¢é˜…ä»»åŠ¡è¿›åº¦ï¼‰
            message = json.loads(data)
            if message.get("type") == "subscribe":
                task_id = message.get("taskId")
                # è®¢é˜…ä»»åŠ¡è¿›åº¦æ›´æ–°
                # è¿™é‡Œå¯ä»¥å®ç°ä»»åŠ¡è¿›åº¦æ¨é€é€»è¾‘
    except WebSocketDisconnect:
        manager.disconnect(websocket, user_id)

async def send_task_progress(user_id: UUID, task_id: UUID, progress: int, status: str, details: dict = None):
    """å‘é€ä»»åŠ¡è¿›åº¦æ›´æ–°"""
    message = {
        "type": "task.progress",
        "taskId": str(task_id),
        "data": {
            "status": status,
            "progress": progress,
            "details": details or {}
        }
    }
    await manager.send_personal_message(message, user_id)
```

---

## ğŸ³ éƒ¨ç½²é…ç½®

### Docker Compose

#### `infrastructure/docker/docker-compose.yml`

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: directorai
      POSTGRES_PASSWORD: directorai
      POSTGRES_DB: directorai
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U directorai"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  minio:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    volumes:
      - minio_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

  agent-service:
    build:
      context: ../../services/agent-service
      dockerfile: Dockerfile
    ports:
      - "8001:8000"
    environment:
      DATABASE_URL: postgresql://directorai:directorai@postgres:5432/directorai
      REDIS_URL: redis://redis:6379
      GLM_API_KEY: ${GLM_API_KEY}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  media-service:
    build:
      context: ../../services/media-service
      dockerfile: Dockerfile
    ports:
      - "8002:8000"
    environment:
      DATABASE_URL: postgresql://directorai:directorai@postgres:5432/directorai
      REDIS_URL: redis://redis:6379
      MINIO_ENDPOINT: minio:9000
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: minioadmin
      TUZI_API_KEY: ${TUZI_API_KEY}
      GEMINI_API_KEY: ${GEMINI_API_KEY}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy

volumes:
  postgres_data:
  redis_data:
  minio_data:
```

---

## ğŸ“ å®æ–½æ­¥éª¤

### é˜¶æ®µä¸€ï¼šé¡¹ç›®åˆå§‹åŒ–ï¼ˆç¬¬1å‘¨ï¼‰

1. **åˆ›å»ºé¡¹ç›®ç»“æ„**
   ```bash
   mkdir -p backend/{api-gateway,services/{agent-service,media-service,data-service},shared,infrastructure,tests,scripts}
   ```

2. **åˆå§‹åŒ– Python é¡¹ç›®**
   ```bash
   cd backend/services/agent-service
   python -m venv venv
   source venv/bin/activate
   pip install fastapi uvicorn sqlalchemy psycopg2-binary redis python-jose passlib
   ```

3. **åˆ›å»º requirements.txt**
   ```txt
   fastapi==0.104.1
   uvicorn==0.24.0
   sqlalchemy==2.0.23
   psycopg2-binary==2.9.9
   redis==5.0.1
   pydantic==2.5.0
   python-jose==3.3.0
   passlib[bcrypt]==1.7.4
   python-multipart==0.0.6
   httpx==0.25.2
   ```

### é˜¶æ®µäºŒï¼šæ ¸å¿ƒåŠŸèƒ½å®ç°ï¼ˆç¬¬2-3å‘¨ï¼‰

1. **å®ç°å…±äº«æ¨¡å—**
   - æ•°æ®æ¨¡å‹
   - å·¥å…·ç±»
   - æ•°æ®åº“é…ç½®

2. **å®ç° Agent Service**
   - è®¤è¯ API
   - å¯¹è¯ API
   - ä»»åŠ¡ API
   - å‰§æœ¬ API
   - GLM å®¢æˆ·ç«¯

3. **å®ç° Media Service**
   - å›¾ç‰‡ç”Ÿæˆ API
   - è§†é¢‘ç”Ÿæˆ API
   - Tuzi/Gemini å®¢æˆ·ç«¯

### é˜¶æ®µä¸‰ï¼šé›†æˆå’Œæµ‹è¯•ï¼ˆç¬¬4å‘¨ï¼‰

1. **æ•°æ®åº“è¿ç§»**
2. **API é›†æˆæµ‹è¯•**
3. **WebSocket æµ‹è¯•**
4. **éƒ¨ç½²é…ç½®**

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2026-01-12
